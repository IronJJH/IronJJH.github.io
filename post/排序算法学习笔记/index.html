<!DOCTYPE html>
<html lang="zh-cn">
			
				HTML
				
					
				
				
						
				
			
		<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://IronJJH.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://IronJJH.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://IronJJH.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://IronJJH.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://IronJJH.github.io/css/light.css' />
    <link rel="stylesheet" href='https://IronJJH.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://IronJJH.github.io/css/syntax.css' />
    <title>排序算法学习笔记 - IronMan&#39;s Secret</title>
    
    <link rel="icon" type="image/x-icon" href='/images/avatar.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="一、冒泡排序
冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
三种不同的冒泡实现
1.不算是标准的冒泡排序算法，不满足“两两交换相邻记录”的冒泡排序思想
思路：让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。
![image-20220112094345821](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094345821.png)
缺陷：在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数字3反而还被换到了最后一位）。
2.正宗的冒泡排序算法
思路：每一次都从最后一个位置开始往前两两比较，前一个大于后一个则交换，第一次会把最小的关键字交换到第一个位置，第二次把第二小的关键字交换到第二个位置，，，如此往复。排序完成。
![image-20220112094516045](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094516045.png)
缺陷：如果待排序的序列是{2,1,3,4,5,6,7,8,9}，那么除了第一和第二的关键字需要交换外，别的都已经是正常的顺序。当i=1时，交换了2和1，此时序列已经有序，但是算法却还会继续执行i=2到9以及每个循环中的j循环
3.优化后的冒泡排序
思路：增加一个标记变量flag，记录一趟下来是否有交换发生
#define MAXSIZE 10  typedef struct{ int r[MAXSIZE&#43;1]; int length; }SqList; void swap(SqList *L,int i,int j){ int temp=L-&amp;gt;r[i]; L-&amp;gt;r[i]=L-&amp;gt;r[j]; L-&amp;gt;r[j]=temp; } //三种冒泡排序 //简单冒泡排序 void BubbleSort0(SqList *L){ for(int i=1;i&amp;lt;L-&amp;gt;length-1;i&#43;&#43;){ for(int j=i&#43;1;j&amp;lt;=L-&amp;gt;length;j&#43;&#43;){ if(L-&amp;gt;r[i]&amp;gt;L-&amp;gt;r[j]) swap(L,i,j); } } } //正宗冒泡排序 void BubbleSort(SqList *L){ for(int i=1;i&amp;lt;L-&amp;gt;length;i&#43;&#43;){ for(int j=L-&amp;gt;length-1;j&amp;gt;i;j--){ if(L-&amp;gt;r[j&#43;1]&amp;lt;L-&amp;gt;r[j]) swap(L,j,j&#43;1); } } } //优化冒泡排序 void BubbleSort1(SqList *L){ static bool flag=true; for(int i=1;i&amp;lt;L-&amp;gt;length&amp;amp;&amp;amp;flag;i&#43;&#43;){ flag=false; for(int j=L-&amp;gt;length-1;j&amp;gt;i;j--){ if(L-&amp;gt;r[j&#43;1]&amp;lt;L-&amp;gt;r[j]) swap(L,j,j&#43;1); flag=true; } } } 二、选择排序" />
<meta name="keywords"
  content='' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://IronJJH.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="排序算法学习笔记 - IronMan&#39;s Secret" />
<meta name="twitter:description"
  content="一、冒泡排序
冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
三种不同的冒泡实现
1.不算是标准的冒泡排序算法，不满足“两两交换相邻记录”的冒泡排序思想
思路：让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。
![image-20220112094345821](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094345821.png)
缺陷：在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数字3反而还被换到了最后一位）。
2.正宗的冒泡排序算法
思路：每一次都从最后一个位置开始往前两两比较，前一个大于后一个则交换，第一次会把最小的关键字交换到第一个位置，第二次把第二小的关键字交换到第二个位置，，，如此往复。排序完成。
![image-20220112094516045](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094516045.png)
缺陷：如果待排序的序列是{2,1,3,4,5,6,7,8,9}，那么除了第一和第二的关键字需要交换外，别的都已经是正常的顺序。当i=1时，交换了2和1，此时序列已经有序，但是算法却还会继续执行i=2到9以及每个循环中的j循环
3.优化后的冒泡排序
思路：增加一个标记变量flag，记录一趟下来是否有交换发生
#define MAXSIZE 10  typedef struct{ int r[MAXSIZE&#43;1]; int length; }SqList; void swap(SqList *L,int i,int j){ int temp=L-&amp;gt;r[i]; L-&amp;gt;r[i]=L-&amp;gt;r[j]; L-&amp;gt;r[j]=temp; } //三种冒泡排序 //简单冒泡排序 void BubbleSort0(SqList *L){ for(int i=1;i&amp;lt;L-&amp;gt;length-1;i&#43;&#43;){ for(int j=i&#43;1;j&amp;lt;=L-&amp;gt;length;j&#43;&#43;){ if(L-&amp;gt;r[i]&amp;gt;L-&amp;gt;r[j]) swap(L,i,j); } } } //正宗冒泡排序 void BubbleSort(SqList *L){ for(int i=1;i&amp;lt;L-&amp;gt;length;i&#43;&#43;){ for(int j=L-&amp;gt;length-1;j&amp;gt;i;j--){ if(L-&amp;gt;r[j&#43;1]&amp;lt;L-&amp;gt;r[j]) swap(L,j,j&#43;1); } } } //优化冒泡排序 void BubbleSort1(SqList *L){ static bool flag=true; for(int i=1;i&amp;lt;L-&amp;gt;length&amp;amp;&amp;amp;flag;i&#43;&#43;){ flag=false; for(int j=L-&amp;gt;length-1;j&amp;gt;i;j--){ if(L-&amp;gt;r[j&#43;1]&amp;lt;L-&amp;gt;r[j]) swap(L,j,j&#43;1); flag=true; } } } 二、选择排序" />
<meta name="twitter:site" content="https://IronJJH.github.io/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://IronJJH.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="排序算法学习笔记 - IronMan&#39;s Secret">
<meta property="og:description"
  content="一、冒泡排序
冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
三种不同的冒泡实现
1.不算是标准的冒泡排序算法，不满足“两两交换相邻记录”的冒泡排序思想
思路：让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。
![image-20220112094345821](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094345821.png)
缺陷：在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数字3反而还被换到了最后一位）。
2.正宗的冒泡排序算法
思路：每一次都从最后一个位置开始往前两两比较，前一个大于后一个则交换，第一次会把最小的关键字交换到第一个位置，第二次把第二小的关键字交换到第二个位置，，，如此往复。排序完成。
![image-20220112094516045](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094516045.png)
缺陷：如果待排序的序列是{2,1,3,4,5,6,7,8,9}，那么除了第一和第二的关键字需要交换外，别的都已经是正常的顺序。当i=1时，交换了2和1，此时序列已经有序，但是算法却还会继续执行i=2到9以及每个循环中的j循环
3.优化后的冒泡排序
思路：增加一个标记变量flag，记录一趟下来是否有交换发生
#define MAXSIZE 10  typedef struct{ int r[MAXSIZE&#43;1]; int length; }SqList; void swap(SqList *L,int i,int j){ int temp=L-&amp;gt;r[i]; L-&amp;gt;r[i]=L-&amp;gt;r[j]; L-&amp;gt;r[j]=temp; } //三种冒泡排序 //简单冒泡排序 void BubbleSort0(SqList *L){ for(int i=1;i&amp;lt;L-&amp;gt;length-1;i&#43;&#43;){ for(int j=i&#43;1;j&amp;lt;=L-&amp;gt;length;j&#43;&#43;){ if(L-&amp;gt;r[i]&amp;gt;L-&amp;gt;r[j]) swap(L,i,j); } } } //正宗冒泡排序 void BubbleSort(SqList *L){ for(int i=1;i&amp;lt;L-&amp;gt;length;i&#43;&#43;){ for(int j=L-&amp;gt;length-1;j&amp;gt;i;j--){ if(L-&amp;gt;r[j&#43;1]&amp;lt;L-&amp;gt;r[j]) swap(L,j,j&#43;1); } } } //优化冒泡排序 void BubbleSort1(SqList *L){ static bool flag=true; for(int i=1;i&amp;lt;L-&amp;gt;length&amp;amp;&amp;amp;flag;i&#43;&#43;){ flag=false; for(int j=L-&amp;gt;length-1;j&amp;gt;i;j--){ if(L-&amp;gt;r[j&#43;1]&amp;lt;L-&amp;gt;r[j]) swap(L,j,j&#43;1); flag=true; } } } 二、选择排序" />
<meta property="og:url" content="https://IronJJH.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" />
<meta property="og:site_name" content="排序算法学习笔记" />
<meta property="og:image"
  content="https://IronJJH.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">










</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://IronJJH.github.io/">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://IronJJH.github.io/">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://IronJJH.github.io/">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1"
          width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>
  
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://IronJJH.github.io/">
                  <img class=" avatar-user"
                    src="https://IronJJH.github.io/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://IronJJH.github.io/">Iron</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://IronJJH.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">排序算法学习笔记</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Mon, 01 Jan 0001 00:00:00 &#43;0000"
                    class="no-wrap">
                    Mon, 01 Jan 0001 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Mon, 01 Jan 0001 00:00:00 &#43;0000"
                    class="no-wrap">
                    Mon, 01 Jan 0001 00:00:00 &#43;0000</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" class="btn btn-octicon m-0 mr-2 p-2" aria-haspopup="menu" aria-label="Table of Contents" role="button">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                          3480 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5">
                <article class="markdown-body entry-content container-lg"><p>一、冒泡排序</p>
<p><!-- raw HTML omitted -->冒泡排序（Bubble Sort）<!-- raw HTML omitted -->一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>
<p>三种不同的冒泡实现</p>
<p>1.不算是标准的冒泡排序算法，不满足“两两交换相邻记录”的冒泡排序思想</p>
<p>思路：让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。</p>
<p>![image-20220112094345821](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094345821.png)</p>
<p>缺陷：在排序好1和2的位置后，对其余关键字的排序没有什么帮助（数字3反而还被换到了最后一位）。</p>
<p>2.正宗的冒泡排序算法</p>
<p>思路：每一次都从最后一个位置开始往前两两比较，前一个大于后一个则交换，第一次会把最小的关键字交换到第一个位置，第二次把第二小的关键字交换到第二个位置，，，如此往复。排序完成。</p>
<p>![image-20220112094516045](/Users/ironman/Library/Application Support/typora-user-images/image-20220112094516045.png)</p>
<p>缺陷：如果待排序的序列是{2,1,3,4,5,6,7,8,9}，那么除了第一和第二的关键字需要交换外，别的都已经是正常的顺序。当i=1时，交换了2和1，此时序列已经有序，但是算法却还会继续执行i=2到9以及每个循环中的j循环</p>
<p>3.优化后的冒泡排序</p>
<p>思路：增加一个标记变量flag，记录一趟下来是否有交换发生</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//三种冒泡排序
</span><span class="c1">//简单冒泡排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">BubbleSort0</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//正宗冒泡排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//优化冒泡排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">BubbleSort1</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">flag</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">flag</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>二、选择排序</p>
<p><!-- raw HTML omitted -->简单选择排序（Simple Selection Sort）<!-- raw HTML omitted -->就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//简单选择排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">min</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
                <span class="n">min</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">min</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">min</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>三、插入排序</p>
<p><!-- raw HTML omitted -->直接插入排序（Straight Insertion Sort）<!-- raw HTML omitted -->的基本操作时将一个记录插入到已经排好序到有序表中，从而得到一个新的、记录数增1的有序表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//直接插入排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
            <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
                <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>插入排序在两种情况下效率是很高的：</p>
<p>1.记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录的排序工作，此时直接插入很高效。</p>
<p>2.记录数较少时，直接插入的优势也比较明显。</p>
<p>四、希尔排序</p>
<p><!-- raw HTML omitted -->希尔排序（Shell Sort）<!-- raw HTML omitted -->的主要思想就是创造出以上两个条件进行直接插入排序。可以说希尔排序就是通过以下两个策略进行优化后的插入排序：</p>
<p>1.将原本有大量记录数的记录进行分组。对分组进行直接插入排序。</p>
<p>2.分组策略的选择就是最终的记录集是否基本有序的关键。在这里我们采取跳跃分割的分组策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。在整个希尔排序过程中存在一个增量序列且增量序列的最后一个增量值必须等于1，在进行最后一趟增量值为1的直接插入排序之前，原序列集已达成基本有序的要求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//希尔排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">increment</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
  <span class="k">do</span><span class="p">{</span>
    <span class="n">increment</span><span class="o">=</span><span class="n">increment</span><span class="o">/</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">increment</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">increment</span><span class="p">]){</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">increment</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">j</span><span class="o">-=</span><span class="n">increment</span><span class="p">){</span>
          <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">increment</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">incremnet</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">increment</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>五、堆排序</p>
<p><!-- raw HTML omitted -->堆（heap）<!-- raw HTML omitted -->是具有下列性质的<!-- raw HTML omitted -->完全二叉树<!-- raw HTML omitted -->：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p>从这里的定义可以看出根结点一定是堆中所有结点最大（小）者。这是实现堆排序的前提。</p>
<p>按照层序遍历的序号将堆的结点的值存入数组，起始序号为1。双亲结点序号为k时，左孩子结点序号为2*k，右孩子结点序号为2*k+1。结点总数为n时，最后一个有孩子的结点序号为n/2 。</p>
<p><!-- raw HTML omitted -->堆排序（Heap Sort）<!-- raw HTML omitted -->的主要思想就是先将待排序的序列构造成一个大顶堆，然后交换其根结点和最后一个结点，此时最后一个结点变成了最大值；接着<!-- raw HTML omitted -->维护<!-- raw HTML omitted -->第一个结点使剩下的n-1个结点变成大顶堆，同样交换根结点和最后一个结点，此时最后一个结点变成了剩下的n-1个结点的最大值，也是所有结点的次大值；如此循环直至最后所有结点都变得有序。</p>
<p>其中<!-- raw HTML omitted -->维护大顶堆<!-- raw HTML omitted -->是整个思想的核心：被交换到首位的结点即是我们需要维护的结点，先找到该结点与其左右孩子结点中的最大值的位置，交换该结点与最大值位置结点，递归维护最大值位置结点。</p>
<p>简单来说，只要交换了两个结点，就需要维护使其仍然是大顶堆。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//堆的维护，i是结点的序号
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HeapFit</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">largest</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lson</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rson</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">lson</span><span class="p">])</span>
        <span class="n">largest</span><span class="o">=</span><span class="n">lson</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">rson</span><span class="p">])</span>
        <span class="n">largest</span><span class="o">=</span><span class="n">rson</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">largest</span><span class="o">!=</span><span class="n">i</span><span class="p">){</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">largest</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
        <span class="n">HeapFit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">largest</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//堆排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="c1">//保存L-&gt;length的初值
</span><span class="c1"></span>    
    <span class="c1">//建堆，从最后一个有孩子的结点开始维护
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">HeapFit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">//堆排序
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
        <span class="n">HeapFit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>六、归并排序</p>
<p><!-- raw HTML omitted -->归并排序（Merging Sort）<!-- raw HTML omitted -->的主要思想是划分与归并。首先将一个序列递归二分划分，最后划分成n个单个的有序序列，然后再按划分时候的路径归并回去。<!-- raw HTML omitted -->重点<!-- raw HTML omitted -->在归并的时候是对两个已排好序的有序序列进行归并得到一个有序序列，归并时因为两个序列已经分别有序，所以只需设置两个指向头元素的指针，进行比较将较小值放入临时数组，然后较小值指针和临时数组指针同时加一，重复此操作，最后两个有序序列中剩余的元素直接复制到临时数组即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>


<span class="c1">//归并排序
</span><span class="c1">//归并的实现
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">tempL</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">l_pos</span><span class="o">=</span><span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r_pos</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="o">=</span><span class="n">left</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">l_pos</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">r_pos</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">l_pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">r_pos</span><span class="p">])</span>
            <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">l_pos</span><span class="o">++</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">r_pos</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="n">l_pos</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span>
        <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">l_pos</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r_pos</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">)</span>
        <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">r_pos</span><span class="o">++</span><span class="p">];</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">){</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">tempL</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="c1">//划分
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">MSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">tempL</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
        <span class="n">Merge</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">right</span><span class="p">);</span><span class="c1">//归并
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//归并排序入口
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tempL</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tempL</span><span class="p">){</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>七、快速排序</p>
<p><!-- raw HTML omitted -->快速排序<!-- raw HTML omitted -->的主要思想是先在待排序序列中选出一个关键字，然后想办法将它放到一个位置使得它左边的值都比它小，右边的值都比它大，我们把这样的关键字称为<!-- raw HTML omitted -->枢轴<!-- raw HTML omitted -->。然后再对其左右两边的序列再递归做同样的操作。那么如何将<!-- raw HTML omitted -->枢轴<!-- raw HTML omitted -->放到对应的位置就是该算法的关键：首先使用两个指针i，j指向每一次待排序序列的第一个位置，指针pivot指向最后一个位置，j遍历序列的序号，如果j指向的值小于pivot指向的值就将i和j指向的值交换并且i加加，到最后i指向的就是序列中第一个比pivot指向的值大的位置，最后交换i指向的值和pivot指向的值，就使得<!-- raw HTML omitted -->枢轴<!-- raw HTML omitted -->处在了自己对应的位置即 i。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define MAXSIZE 10
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>


<span class="c1">//快速排序
</span><span class="c1">//寻找枢轴的正确位置
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pivot</span><span class="p">;</span>
    <span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">;</span>
    <span class="n">pivot</span><span class="o">=</span><span class="n">high</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">high</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">pivot</span><span class="p">]){</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//递归对枢轴两边的序列进行排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">QSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="n">partition</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
        <span class="n">QSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">QSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">//快速排序入口
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="n">QSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p><!-- raw HTML omitted -->总结验证：冒泡最慢；选择和插入次之（选择大概是插入的两倍）；希尔、堆、归并、快速更快（四者速度相当）。<!-- raw HTML omitted --></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//MAXSIZE表示待排序列的长度
</span><span class="c1"></span><span class="cp">#define MAXSIZE 100000
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span>

<span class="c1">//交换序列中i位置和j位置的值
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//打印序列
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">print_SqList</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//初始化序列
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">CreatList</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">=</span><span class="n">MAXSIZE</span><span class="p">;</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">MAXSIZE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//三种冒泡排序
</span><span class="c1">//简单冒泡排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">BubbleSort0</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//正宗冒泡排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//优化冒泡排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">BubbleSort1</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">flag</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">flag</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="c1">//简单选择排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">min</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
                <span class="n">min</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">min</span><span class="p">)</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">min</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//直接插入排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
            <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
                <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">//希尔排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">increment</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">increment</span><span class="o">=</span><span class="n">increment</span><span class="o">/</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">increment</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">increment</span><span class="p">]){</span>
                <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">increment</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">j</span><span class="o">-=</span><span class="n">increment</span><span class="p">)</span>
                    <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">increment</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">increment</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">increment</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//堆的维护，i是结点的序号
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HeapFit</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">largest</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lson</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rson</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">lson</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">lson</span><span class="p">])</span>
        <span class="n">largest</span><span class="o">=</span><span class="n">lson</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rson</span><span class="o">&lt;=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">&amp;&amp;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">rson</span><span class="p">])</span>
        <span class="n">largest</span><span class="o">=</span><span class="n">rson</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">largest</span><span class="o">!=</span><span class="n">i</span><span class="p">){</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">largest</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
        <span class="n">HeapFit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">largest</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//堆排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="c1">//保存L-&gt;length的初值
</span><span class="c1"></span>    <span class="c1">//建堆，从最后一个有孩子的结点开始维护
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">HeapFit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//堆排序
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
        <span class="n">HeapFit</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>






<span class="c1">//  归并排序（大话数据结构中的思路）
</span><span class="c1">//  void Merge(int SR[],int TR[],int i,int m, int n){
</span><span class="c1">//      int j,k ,l;
</span><span class="c1">//      for(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;k++){
</span><span class="c1">//          if(SR[i]&lt;SR[j])
</span><span class="c1">//             TR[k]=SR[i++];
</span><span class="c1">//          else
</span><span class="c1">//             TR[k]=SR[j++];
</span><span class="c1">//      }
</span><span class="c1">//      if(i&lt;=m){
</span><span class="c1">//          for(l=0;l&lt;=m-i;l++)
</span><span class="c1">//             TR[k+l]=SR[i+l];
</span><span class="c1">//      }
</span><span class="c1">//      if(j&lt;=n){
</span><span class="c1">//         for(l=0;l&lt;=n-j;l++)
</span><span class="c1">//             TR[k+l]=SR[j+l];
</span><span class="c1">//      }
</span><span class="c1">//  }
</span><span class="c1"></span>
<span class="c1">// void MSort(int SR[],int TR1[],int s,int t){
</span><span class="c1">//     int m;
</span><span class="c1">//     int TR2[MAXSIZE+1];
</span><span class="c1">//     if(s==t)
</span><span class="c1">//         TR1[s]=SR[s];
</span><span class="c1">//     else{
</span><span class="c1">//         m=(s+t)/2;
</span><span class="c1">//         MSort(SR,TR2,s,m);
</span><span class="c1">//         MSort(SR,TR2,m+1,t);
</span><span class="c1">//         Merge(TR2,TR1,s,m,t);
</span><span class="c1">//     }
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// void MergeSort(SqList *L){
</span><span class="c1">//     MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);
</span><span class="c1">// }
</span><span class="c1"></span>


<span class="c1">//归并排序
</span><span class="c1">//归并
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">tempL</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">l_pos</span><span class="o">=</span><span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r_pos</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="o">=</span><span class="n">left</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">l_pos</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">r_pos</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">l_pos</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">r_pos</span><span class="p">])</span>
            <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">l_pos</span><span class="o">++</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">r_pos</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="n">l_pos</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span>
        <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">l_pos</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r_pos</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">)</span>
        <span class="n">tempL</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">r_pos</span><span class="o">++</span><span class="p">];</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="p">){</span>
        <span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">tempL</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="c1">//划分
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">MSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">tempL</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
        <span class="n">Merge</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//归并排序入口
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tempL</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tempL</span><span class="p">){</span>
        <span class="n">MSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">tempL</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="c1">// //快速排序（大话数据结构中的思路）
</span><span class="c1">// int Partition(SqList *L,int low,int high){
</span><span class="c1">//     int pivotkey;
</span><span class="c1">//     pivotkey=L-&gt;r[low];
</span><span class="c1">//     while(low&lt;high){
</span><span class="c1">//         while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
</span><span class="c1">//             high--;
</span><span class="c1">//         swap(L,low,high);
</span><span class="c1">//         while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
</span><span class="c1">//             low++;
</span><span class="c1">//         swap(L,low,high);
</span><span class="c1">//     }
</span><span class="c1">//     return low;
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// void QSort(SqList *L,int low,int high){
</span><span class="c1">//     int pivot;
</span><span class="c1">//     if(low&lt;high){
</span><span class="c1">//         pivot=Partition(L,low,high);
</span><span class="c1"></span>
<span class="c1">//         QSort(L,low,pivot-1);
</span><span class="c1">//         QSort(L,pivot+1,high);
</span><span class="c1">//     }
</span><span class="c1">// }
</span><span class="c1"></span>

<span class="c1">// void QuickSort(SqList *L){
</span><span class="c1">//     QSort(L,1,L-&gt;length);
</span><span class="c1">// }
</span><span class="c1"></span>

<span class="c1">//快速排序
</span><span class="c1">//寻找枢轴的正确位置
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pivot</span><span class="p">;</span>
    <span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">;</span>
    <span class="n">pivot</span><span class="o">=</span><span class="n">high</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">high</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">pivot</span><span class="p">]){</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//递归对枢轴两边的序列进行排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">QSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="n">partition</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
        <span class="n">QSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">QSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">//快速排序入口
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">*</span><span class="n">L</span><span class="p">){</span>
    <span class="n">QSort</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">SqList</span> <span class="n">L</span><span class="p">;</span>
    <span class="n">SqList</span> <span class="n">L1</span><span class="p">,</span><span class="n">L2</span><span class="p">,</span><span class="n">L3</span><span class="p">,</span><span class="n">L4</span><span class="p">,</span><span class="n">L5</span><span class="p">,</span><span class="n">L6</span><span class="p">,</span><span class="n">L7</span><span class="p">;</span>

    <span class="n">CreatList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
    <span class="n">L1</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L2</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L3</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L4</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L5</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L6</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L7</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">L1</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L2</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L3</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L4</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L5</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L6</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L7</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    

    <span class="n">clock_t</span> <span class="n">start_time1</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">BubbleSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L1</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time1</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">//cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">//print_SqList(&amp;L1);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;1.Bubble Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time1</span> <span class="o">-</span> <span class="n">start_time1</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">clock_t</span> <span class="n">start_time2</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">SelectSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L2</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time2</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">//cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">//print_SqList(&amp;L2);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;2.Select Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time2</span> <span class="o">-</span> <span class="n">start_time2</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">clock_t</span> <span class="n">start_time3</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">InsertSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L3</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time3</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">// cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">// print_SqList(&amp;L3);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;3.Insert Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time3</span> <span class="o">-</span> <span class="n">start_time3</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">clock_t</span> <span class="n">start_time4</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">ShellSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L4</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time4</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">// cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">// print_SqList(&amp;L4);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;4.Shell Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time4</span> <span class="o">-</span> <span class="n">start_time4</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">clock_t</span> <span class="n">start_time5</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">HeapSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L5</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time5</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">// cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">// print_SqList(&amp;L5);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;5.Heap Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time5</span> <span class="o">-</span> <span class="n">start_time5</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


    <span class="n">clock_t</span> <span class="n">start_time6</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">MergeSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L6</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time6</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">// cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">// print_SqList(&amp;L6);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;6.Merge Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time6</span> <span class="o">-</span> <span class="n">start_time6</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">clock_t</span> <span class="n">start_time7</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L7</span><span class="p">);</span>
    <span class="n">clock_t</span> <span class="n">end_time7</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
    <span class="c1">// cout&lt;&lt;endl;
</span><span class="c1"></span>    <span class="c1">// print_SqList(&amp;L7);
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;7.Quick Sort Time:&#34;</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end_time7</span> <span class="o">-</span> <span class="n">start_time7</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script>
 
 
 
 window.onload = function () {
   const header = document.getElementById('post-header');
   const headerHeight = header.offsetHeight;
   
   document.documentElement.style.scrollPaddingTop = headerHeight + 10 + "px";
 }

 const tocToggleButton = document.getElementById("toc-toggle");

 const tippyInstance = tippy('#toc-toggle', {
  trigger: 'click',
  content: '<div id="table-of-contents">\u003cnav id=\u0022TableOfContents\u0022\u003e\u003c\/nav\u003e</div>',
  allowHTML: true,
  placement: 'bottom-start',
  interactive: true,
  arrow: false,
  maxWidth: "none",
  onHide: function () { tocToggleButton.classList.remove("hover"); },
  onShow: function () { tocToggleButton.classList.add("hover"); },
  onShown: function () {
    selectTableOfContentsOption();

    if (window.hasSetupTableOfContentsListeners) {
      return;
    }

    const tableOfContents = document.getElementById("table-of-contents");
    tableOfContents.addEventListener('click', function () {
      
      tippyInstance[0].hide();
    });

    window.hasSetupTableOfContentsListeners = true;
  }
 });

 function selectTableOfContentsOption () {
   const optionSelectedClass = 'table-of-contents-option-selected';

   const tableOfContentsOptions = document.querySelectorAll("#table-of-contents > nav > ul li");

   for (const option of tableOfContentsOptions) {
     

     const [child] = option.children;
     if (child.tagName.toLowerCase() !== 'a') {
       continue;
     }

     if (window.location.href === child.href) {
       child.classList.add(optionSelectedClass);
     } else {
       child.classList.remove(optionSelectedClass);
     }
   }
 }

 window.onhashchange = selectTableOfContentsOption;
</script>


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://IronJJH.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://IronJJH.github.io/js/github-style.js"></script>



</html>